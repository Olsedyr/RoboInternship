//Code generated by bxbuilder (c) LMS 2002 
// formScopeDataUser.c
#ifdef USEFFT
#include <fftw3.h>
#endif
#include <math.h>
#include "Bx.h"
#include "BxGdi.h"
#include "formScopeData.h"
#include "cmd.h"
#include "stm.h"

#define MAXTABLESIZE 5000
#define DEFAULTTABLESIZE 500


static int WINDOWHEIGHT=350;
static int WINDOWOFFSETY=400;
static int WINDOWOFFSETX=50;


static int itemIndex=0;
static int capture=0;
static int ft_enable=0;
static int dt_enable=0;
static int trackx=0;
static int tracky=0;
static int didx=0;
static int dcurtablesize=0;
static int dmin=0,dmax=0;
static float fdmin=0,fdmax=0;
static float ftmin=0,ftmax=0;
static float dtmin=0,dtmax=0;
static float ftracky=0.0;
static int dtable[MAXTABLESIZE];
static float fdtable[MAXTABLESIZE];
static float ftdata[MAXTABLESIZE];
static int *pdtable;
static float *pfdtable;
//tmpnScopeData scopeitem[10];

#ifdef USEFFT
static double *in;
static fftw_complex *out;
static fftw_plan p;
#endif

static BXMENUSTRUCT pBxScopeMenu;

static int wstm = -1;
static int statew_idle = -1;
static int statew_running = -1;
static int statew_paused = -1;
static int statew_error = -1;
static int emergstm = -1;
static int stateemerg_poweron = -1;

static char *trackstr=NULL;
static char *scalestr=NULL;
static char *minstr=NULL;
static char *maxstr=NULL;

static void drawTab(HBOX hBox)
{
  float diff,scale;
	BX_RECT tRc;
  BX_COLORREF oldPen;
  BX_COLORREF oldBrush;
  BOXSTRUCT *b;
  int i;
	
  b = BxGetDlgItem(hBox,FORMSCOPEDATA_DATA);
	BxDC* bdc = BxGetBoxDC(BxGetDlgItem(hBox,FORMSCOPEDATA_DATA));

	oldPen = BxSetPen(bdc, BXSYSTEM_PALETTE[BXCOLOR_BACKGROUND]);
	oldBrush = BxSetBrush(bdc, BXSYSTEM_PALETTE[BXCOLOR_BACKGROUND]);
	
	BxSetRect(&tRc, b->rc.left, b->rc.top, b->rc.right, b->rc.bottom);
	WINDOWOFFSETX=b->rc.left;
	WINDOWOFFSETY=b->rc.bottom;
	WINDOWHEIGHT=b->rc.bottom-b->rc.top;

	BxRectangle(bdc, &tRc);
	
	BxSetPen(bdc, oldPen);
	BxSetBrush(bdc, oldBrush);
	
	if (ft_enable)
	{	
#ifdef USEFFT
		if(scopeitem[itemIndex].sampling->subtype==0)
		{
			for ( i = 0; i < dcurtablesize; i++ )
			{
				in[i] = pdtable[i];
			}
		}
		else
		{
			for ( i = 0; i < dcurtablesize; i++ )
			{
				in[i] = pfdtable[i];
			}
		}
		fftw_execute(p); /* repeat as needed */
		dcurtablesize = ( dcurtablesize  / 2 ) + 1;
		for ( i = 0; i < dcurtablesize; i++ )
		{
			ftdata[i]=sqrt(out[i][0]*out[i][0]+out[i][1]*out[i][1]);
			if (i>0)
			{
				if (ftdata[i] > ftmax)
				{
					ftmax = ftdata[i];
				}
				else if (ftdata[i] < ftmin)
				{
					ftmin = ftdata[i];
				}
			}
		}
		diff=ftmax-ftmin;
    scale=WINDOWHEIGHT/diff;
		//printf("scale %f diff %f max %f min %f dc %f\n",scale,diff,ftmax,ftmin,ftdata[0]);
    for(i=2;i<dcurtablesize;i++)
    {
      BxLine(bdc,WINDOWOFFSETX+i  ,WINDOWOFFSETY-(ftdata[i-1]-ftmin)*scale
						 ,WINDOWOFFSETX+i+1,WINDOWOFFSETY-(ftdata[i]-ftmin)*scale);
    }
#endif		
	}
	else if (dt_enable) 
	{
		float dtdata[MAXTABLESIZE];
		if(scopeitem[itemIndex].sampling->subtype==0)
		{
			for ( i = 1; i < dcurtablesize; i++ )
			{
				if (fabs(i-didx)>2)
					dtdata[i-1] = pdtable[i]-pdtable[i-1];
				else if (!capture)
					dtdata[i-1]=0.0;
				if (!capture) 
				{
					if (dtdata[i-1] > dtmax)
					{
						dtmax = dtdata[i-1];
					}
					else if (dtdata[i-1] < dtmin)
					{
						dtmin = dtdata[i-1];
					}
				}
			}
		}
		else
		{
			for ( i = 1; i < dcurtablesize; i++ )
			{
				if (fabs(i-didx)>2)
					dtdata[i-1] = pfdtable[i]-pfdtable[i-1];
				else if (!capture)
					dtdata[i-1]=0.0;
				if (!capture) 
				{
					if (dtdata[i-1] > dtmax)
					{
						dtmax = dtdata[i-1];
					}
					else if (dtdata[i-1] < dtmin)
					{
						dtmin = dtdata[i-1];
					}
				}
			}
		}
		dcurtablesize-=1;
		diff=dtmax-dtmin;
    scale=WINDOWHEIGHT/diff;
		//printf("scale %f diff %f max %f min %f dc %f\n",scale,diff,ftmax,ftmin,ftdata[0]);
	
		for(i=1;i<dcurtablesize;i++)
		{
			BxLine(bdc,WINDOWOFFSETX+i  ,WINDOWOFFSETY-(dtdata[i-1]-dtmin)*scale
						 ,WINDOWOFFSETX+i+1,WINDOWOFFSETY-(dtdata[i]-dtmin)*scale);
		}
		if(!capture)
		{
			BxLine(bdc,WINDOWOFFSETX+didx,WINDOWOFFSETY-10,WINDOWOFFSETX+didx,b->rc.top+10);
		}
	}
  else if(scopeitem[itemIndex].sampling->subtype==0)
  {
    //use min and max in table to calculate scale
    diff=dmax-dmin;
    scale=WINDOWHEIGHT/diff;
    for(i=1;i<dcurtablesize;i++)
    {
      BxLine(bdc,WINDOWOFFSETX+i  ,WINDOWOFFSETY-(pdtable[i-1]-dmin)*scale
						 ,WINDOWOFFSETX+i+1,WINDOWOFFSETY-(pdtable[i]-dmin)*scale);
    }
		if(!capture)
		{
			BxLine(bdc,WINDOWOFFSETX+didx,WINDOWOFFSETY-10,WINDOWOFFSETX+didx,b->rc.top+10);
		}
  }
  else
  {
    //use fmin and fmax in table to calculate scale
    diff=fdmax-fdmin;
    scale=WINDOWHEIGHT/diff;
    for(i=1;i<dcurtablesize;i++)
    {
      BxLine(bdc,WINDOWOFFSETX+i  ,WINDOWOFFSETY-(pfdtable[i-1]-fdmin)*scale
						 ,WINDOWOFFSETX+i+1,WINDOWOFFSETY-(pfdtable[i]-fdmin)*scale);
    }
		if(!capture)
		{
			BxLine(bdc,WINDOWOFFSETX+didx,WINDOWOFFSETY-10,WINDOWOFFSETX+didx,b->rc.top+10);
		}
	}
	if (!ft_enable && !dt_enable)
	{
		oldPen = BxSetPen(bdc, BX_RGB(0x80,0x00,0x00));
		oldBrush = BxSetBrush(bdc, BX_RGB(0x80,0x00,0x00));
		if(scopeitem[itemIndex].sampling->subtype==0)
		{
			tracky=pdtable[trackx];
			for(i=0;i<4;i++)
			{
				BxLine(bdc,WINDOWOFFSETX+trackx  ,WINDOWOFFSETY-(tracky-dmin)*scale-i,WINDOWOFFSETX+trackx+4,WINDOWOFFSETY-(tracky-dmin)*scale-i);
			}
		}
		else
		{
			ftracky=pfdtable[trackx];
			for(i=0;i<4;i++)
			{
				BxLine(bdc,WINDOWOFFSETX+trackx  ,WINDOWOFFSETY-(ftracky-fdmin)*scale-i,WINDOWOFFSETX+trackx+4,WINDOWOFFSETY-(ftracky-fdmin)*scale-i);
			}
		}
		BxSetPen(bdc, oldPen);
		BxSetBrush(bdc, oldBrush);
	}
}


BX_BOOL formScopeDataUserInit(HBOX hBox,BX_LPARAM lParam)
{ 
	tmpnLanguage *langptr=(tmpnLanguage*)&tworkcell->languages.language[tworkcell->languages.currentLanguage];	
	BxAssignStringValue(BxGetDlgItem(hBox, FORMSCOPEDATA_CMDMENU));
	BxSetStringValue(BxGetDlgItem(hBox, FORMSCOPEDATA_CMDMENU), getLanguageLineFromIdx(langptr, 17, "Menu"));
	BxAssignStringValue(BxGetDlgItem(hBox, FORMSCOPEDATA_TEXTLABEL1));
	BxSetStringValue(BxGetDlgItem(hBox, FORMSCOPEDATA_TEXTLABEL1), getLanguageLineFromIdx(langptr, 88, "Capture"));
	BxAssignStringValue(BxGetDlgItem(hBox, FORMSCOPEDATA_TEXTLABEL2));
	BxSetStringValue(BxGetDlgItem(hBox, FORMSCOPEDATA_TEXTLABEL2), getLanguageLineFromIdx(langptr, 89, "Index"));
	scalestr=getLanguageLineFromIdx(langptr, 90 , "Scale");
	trackstr=getLanguageLineFromIdx(langptr, 91 , "Track");
	minstr=getLanguageLineFromIdx(langptr, 92 , "Min");
	maxstr=getLanguageLineFromIdx(langptr, 93 , "Max");
  BxAssignIntValue(BxGetDlgItem(hBox, FORMSCOPEDATA_CMDINDEX));
  BxAssignIntValue(BxGetDlgItem(hBox, FORMSCOPEDATA_CAPTURE));
  itemIndex=0;
  BxSetIntValue(BxGetDlgItem(hBox, FORMSCOPEDATA_CMDINDEX), itemIndex);
  BxAssignStringValue(BxGetDlgItem(hBox, FORMSCOPEDATA_TEXT));
  BxSetCheck(BxGetDlgItem(hBox, FORMSCOPEDATA_CAPTURE), capture);
	if(scopeitem[itemIndex].sampling->type==TABLE)
	{
		BxScrollBar_SetRange(BxGetDlgItem(hBox, FORMSCOPEDATA_SCROLLBAR1), 0, scopeitem[itemIndex].sampling->table->curtablesize-1);
	}
	else
	{
		BxScrollBar_SetRange(BxGetDlgItem(hBox, FORMSCOPEDATA_SCROLLBAR1), 0, DEFAULTTABLESIZE-1);
	}
	memset(dtable, 0, MAXTABLESIZE*sizeof(int));
	memset(fdtable, 0, MAXTABLESIZE*sizeof(float));
	pdtable=dtable;
	pfdtable=fdtable;

	
	//  sprintf(wname,"WorkCells",cwSlave);
	if ((rs_param.workcellid > 500) && (rs_param.workcellid < 600))
	{
		wstm = getMachineIdx("WorkCellS1");
		emergstm = getMachineIdx("EmergencyS1");
	}
	else
	{
		wstm = getMachineIdx("WorkCell");
		emergstm = getMachineIdx("Emergency");
	}
	
	statew_idle = getStateIdx(wstm, "ST_IDLE");
	statew_running = getStateIdx(wstm, "ST_RUNNING");
	statew_paused = getStateIdx(wstm, "ST_PAUSED");
	statew_error = getStateIdx(wstm, "ST_ERROR");

	stateemerg_poweron = getStateIdx(emergstm,"ST_POWERON");

  return TRUE;
}

BX_BOOL formScopeDataUserUpdate(HBOX hBox)
{
	char hstr[256];
	switch (scopeitem[itemIndex].sampling->type)
	{
	case TABLE:
		if(scopeitem[itemIndex].sampling->table==NULL) return TRUE;
		if(scopeitem[itemIndex].sampling->table->curtablesize > MAXTABLESIZE) return TRUE;
		dcurtablesize=scopeitem[itemIndex].sampling->table->curtablesize;
		didx=scopeitem[itemIndex].sampling->table->maxidx;
		if(scopeitem[itemIndex].sampling->subtype==0)
		{
			if(!capture)
			{
				dmin=scopeitem[itemIndex].sampling->table->min;
				dmax=scopeitem[itemIndex].sampling->table->max;
				pdtable=scopeitem[itemIndex].sampling->table->item;
			}
			else 
			{
				pdtable=dtable;
			}
		}
		else
		{
			if(!capture)
			{
				fdmin=scopeitem[itemIndex].sampling->table->fmin;
				fdmax=scopeitem[itemIndex].sampling->table->fmax;
				pfdtable=scopeitem[itemIndex].sampling->table->fitem;
			}
			else 
			{
				pfdtable=fdtable;
			}
		}
		break;
	case VALUE:
		dcurtablesize=DEFAULTTABLESIZE;
		if(scopeitem[itemIndex].sampling->subtype==0)
		{			
			pdtable=dtable;
			if(!capture)
			{
				dtable[didx++]=scopeitem[itemIndex].sampling->data;
				if (didx==DEFAULTTABLESIZE) didx=0;
				if (scopeitem[itemIndex].sampling->data > dmax) dmax=scopeitem[itemIndex].sampling->data;
				else if (scopeitem[itemIndex].sampling->data < dmin) dmin=scopeitem[itemIndex].sampling->data;
			}
		}
		else
		{
			pfdtable=fdtable;
			if(!capture)
			{
				fdtable[didx++]=scopeitem[itemIndex].sampling->fdata;
				if (didx==DEFAULTTABLESIZE) didx=0;
				if (scopeitem[itemIndex].sampling->fdata > fdmax) fdmax=scopeitem[itemIndex].sampling->fdata;
				else if (scopeitem[itemIndex].sampling->fdata < fdmin) fdmin=scopeitem[itemIndex].sampling->fdata;
			}
		}
		break;
	case CONSTANT:
	case LINKVALUE:
		return TRUE;
	}
	drawTab(hBox);
	if(ft_enable)
	{
		sprintf(hstr,"%s %0.2f %s=%0.2f %s=%0.2f dc=%f"
						,scalestr
						,ftmax-ftmin
						,minstr
						,ftmin
						,maxstr
						,ftmax
						,ftdata[0]/(float)((dcurtablesize-1)*2));
	}
	else if(dt_enable)
	{
		sprintf(hstr,"%s %0.2f %s=%0.2f %s=%0.2f"
						,scalestr
						,dtmax-dtmin
						,minstr
						,dtmin
						,maxstr
						,dtmax
						);
	}
	else if(scopeitem[itemIndex].sampling->subtype==0)
	{
		sprintf(hstr,"%s %d %s=%d %s=%d %s=(%d,%d)"
						,scalestr
						,dmax-dmin
						,minstr
						,dmin
						,maxstr
						,dmax
						,trackstr
						,trackx
						,tracky);
	}
	else
	{
		sprintf(hstr,"%s %0.2f %s=%0.2f %s=%0.2f %s=(%d,%0.2f)"
						,scalestr
						,fdmax-fdmin
						,minstr
						,fdmin	
						,maxstr
						,fdmax
						,trackstr
						,trackx
						,ftracky);
	}
	BxSetStringValue(BxGetDlgItem(hBox, FORMSCOPEDATA_TEXT), hstr);
	BxSetCheck(BxGetDlgItem(hBox, FORMSCOPEDATA_CAPTURE), capture);
	return TRUE;
}

BX_BOOL formScopeData_DT_Click(HBOX hBox)
{
	dt_enable=!dt_enable;
	if (dt_enable&&!capture)
	{
		dtmax=-999999999;
		dtmin=999999999;
	}
	return TRUE;
}

BX_BOOL formScopeData_FT_Click(HBOX hBox)
{
	ft_enable=!ft_enable;
#ifdef USEFFT
	if (ft_enable)
	{
		switch (scopeitem[itemIndex].sampling->type)
		{
		case TABLE:
			if(scopeitem[itemIndex].sampling->table==NULL) return TRUE;
			if(scopeitem[itemIndex].sampling->table->curtablesize > MAXTABLESIZE) return TRUE;
			dcurtablesize=scopeitem[itemIndex].sampling->table->curtablesize;
			break;
		case VALUE:
			dcurtablesize=DEFAULTTABLESIZE;
			break;
		default:
			return TRUE;
		}
		ftmax=-999999999;
		ftmin=999999999;
		in = fftw_malloc ( sizeof ( double ) * dcurtablesize );
		out = fftw_malloc ( sizeof ( fftw_complex ) * (( dcurtablesize  / 2 ) + 1) );
		
		p = fftw_plan_dft_r2c_1d ( dcurtablesize, in, out, FFTW_ESTIMATE );
		
	}
	else 
	{
		fftw_destroy_plan(p);
		fftw_free ( in );
	  fftw_free ( out );		
	}
#endif
	return TRUE;
}

BX_BOOL formScopeData_Capture_Click(HBOX hBox)
{
	int i;
  capture = BxGetCheck(BxGetDlgItem(hBox, FORMSCOPEDATA_CAPTURE));
	if (capture&&(scopeitem[itemIndex].sampling->type==TABLE))
	{
		if(scopeitem[itemIndex].sampling->subtype==0)
		{
			memcpy(dtable,scopeitem[itemIndex].sampling->table->item,sizeof(int)*scopeitem[itemIndex].sampling->table->curtablesize);
			pdtable=dtable;
		}
		else if(scopeitem[itemIndex].sampling->subtype==1)
		{
			memcpy(fdtable,scopeitem[itemIndex].sampling->table->fitem,sizeof(float)*scopeitem[itemIndex].sampling->table->curtablesize);
			pfdtable=fdtable;
		}
	}
	if(!capture)
	{
		if(scopeitem[itemIndex].sampling->subtype==0)
		{
			if (scopeitem[itemIndex].sampling->type==TABLE)
			{
				scopeitem[itemIndex].sampling->table->max=-999999999;
				scopeitem[itemIndex].sampling->table->min=999999999;
				dcurtablesize=scopeitem[itemIndex].sampling->table->curtablesize;
				dmin=scopeitem[itemIndex].sampling->table->min;
				dmax=scopeitem[itemIndex].sampling->table->max;
				pdtable=scopeitem[itemIndex].sampling->table->item;
			}
			else if (scopeitem[itemIndex].sampling->type==VALUE)
			{
				dmax=-999999999;
				dmin=999999999;
				pdtable=dtable;
				dcurtablesize=DEFAULTTABLESIZE;
			}
			else return TRUE;
			for(i=0;i<dcurtablesize;i++)
			{
				if (pdtable[i]>dmax)
					dmax=pdtable[i];
				if (pdtable[i]<dmin)
					dmin=pdtable[i];
			}
			if (scopeitem[itemIndex].sampling->type==TABLE)
			{
				scopeitem[itemIndex].sampling->table->min=dmin;
				scopeitem[itemIndex].sampling->table->max=dmax;
			}
		}
		else if(scopeitem[itemIndex].sampling->subtype==1)
		{
			if (scopeitem[itemIndex].sampling->type==TABLE)
			{
				scopeitem[itemIndex].sampling->table->fmax=-999999999.0;
				scopeitem[itemIndex].sampling->table->fmin=999999999.0;
				dcurtablesize=scopeitem[itemIndex].sampling->table->curtablesize;
				fdmin=scopeitem[itemIndex].sampling->table->fmin;
				fdmax=scopeitem[itemIndex].sampling->table->fmax;
				pfdtable=scopeitem[itemIndex].sampling->table->fitem;
			}
			else if (scopeitem[itemIndex].sampling->type==VALUE)
			{
				fdmax=-999999999.0;
				fdmin=999999999.0;
				pfdtable=fdtable;
				dcurtablesize=DEFAULTTABLESIZE;
			}
			else return TRUE;
			for(i=0;i<dcurtablesize;i++)
			{
				if (pfdtable[i]>fdmax)
					fdmax=pfdtable[i];
				if (pfdtable[i]<fdmin)
					fdmin=pfdtable[i];
			}
			if (scopeitem[itemIndex].sampling->type==TABLE)
			{
				scopeitem[itemIndex].sampling->table->fmin=fdmin;
				scopeitem[itemIndex].sampling->table->fmax=fdmax;
			}
		}
	}
  return TRUE;
}

BX_BOOL formScopeData_cmdClose_Click(HBOX hBox)
{
  BxEndDialog(hBox, 0);
  return TRUE;
}

BX_BOOL formScopeData_cmdStop_Click(HBOX hBox)
{
	if(testState(wstm,statew_running))
  {
		signalContinue();
  }
	return TRUE;
}

BX_BOOL formScopeData_cmdStart_Click(HBOX hBox)
{
  if(testState(wstm,statew_idle)
		 ||testState(wstm,statew_paused)
		 ||testState(wstm,statew_error))
  {
		signalContinue();
  }
	return TRUE;
}

BX_BOOL formScopeData_cmdMenu_Click(HBOX hBox)
{
	HBOX hBx;
	tmpnLanguage *langptr=(tmpnLanguage*)&tworkcell->languages.language[tworkcell->languages.currentLanguage];
  hBx = BxMenu_Create(BxGetDlgItem(hBox, FORMSCOPEDATA_CMDMENU), &pBxScopeMenu);
	if((testState(wstm,statew_idle)
			||testState(wstm,statew_paused)
			||testState(wstm,statew_error))
		 &&testState(emergstm,stateemerg_poweron))
	{
		BxMenu_Add(hBx ,getLanguageLineFromIdx(langptr, 14, "Go"), MENU, formScopeData_cmdStart_Click, TRUE, NULL);
	}
	else
	{
		BxMenu_Add(hBx ,getLanguageLineFromIdx(langptr, 14, "Go"), MENU, formScopeData_cmdStart_Click, FALSE, NULL);
	}
	if((testState(wstm,statew_running))
		 &&testState(emergstm,stateemerg_poweron))
  {
		BxMenu_Add(hBx ,getLanguageLineFromIdx(langptr, 13, "Stop"), MENU, formScopeData_cmdStop_Click, TRUE, NULL);
	}
	else
	{
		BxMenu_Add(hBx ,getLanguageLineFromIdx(langptr, 13, "Stop"), MENU, formScopeData_cmdStop_Click, FALSE, NULL);
	}
  BxMenu_Add(hBx ,getLanguageLineFromIdx(langptr, 54, "Close"), MENU, formScopeData_cmdClose_Click, TRUE, NULL);

	DoMenu(BxGetDlgItem(hBox, FORMSCOPEDATA_CMDMENU));
  return TRUE;
}

BX_BOOL formScopeData_scrollBar1_Click(HBOX hBox)
{
	trackx=BxScrollBar_GetPos(BxGetDlgItem(hBox, FORMSCOPEDATA_SCROLLBAR1));
	return TRUE;
}

BX_BOOL formScopeData_cmdIndex_Click(HBOX hBox)
{
  
  BxVirtNumBox_SetValue(BxGetIntValue(BxGetDlgItem(hBox, FORMSCOPEDATA_CMDINDEX)));
  BxVirtNumBox_SetLimits(0,9);

  if(VirtNumKeyBox( hBox ) == IDOK)
  {
    itemIndex = BxVirtNumBox_GetValue();
    BxSetIntValue(BxGetDlgItem(hBox, FORMSCOPEDATA_CMDINDEX),itemIndex);
  }
  return TRUE;
}
